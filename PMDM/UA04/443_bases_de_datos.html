<!doctype html>
<html lang="es">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="exe_effects.css" />
<link rel="stylesheet" type="text/css" href="exe_highlighter.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>4.4.3. Bases de datos | UA04. Comunicando... </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="author" content="David Bermúdez" />
<link rel="license" type="text/html" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" />
<meta name="generator" content="eXeLearning 2.7 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="exe_effects.js"></script>
<script type="text/javascript" src="exe_highlighter.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<link rel="stylesheet" type="text/css" href="udl-content.css" />
<script type="text/javascript" src="udl-content.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
	</head>
<body class="exe-web-site" id="exe-node-7"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Saltar la navegación</a></p>
<header id="header" ><div id="headerContent">UA04. Comunicando...</div></header>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">UA04. Comunicando...</a></li>
   <li><a href="41_tipos_de_conexiones.html" class="no-ch">4.1. Tipos de conexiones</a></li>
   <li><a href="42_gestin_de_la_comunicacin.html" class="no-ch">4.2. Gestión de la comunicación</a></li>
   <li><a href="43_bsqueda_de_dispositivos.html" class="no-ch">4.3. Búsqueda de dispositivos</a></li>
   <li class="current-page-parent"><a href="44_permanencia.html" class="current-page-parent daddy">4.4. Permanencia</a>
   <ul>
      <li><a href="441_sharedpreferences.html" class="no-ch">4.4.1. SharedPreferences</a></li>
      <li><a href="442_ficheros.html" class="no-ch">4.4.2. Ficheros</a></li>
      <li id="active"><a href="443_bases_de_datos.html" class="active no-ch">4.4.3. Bases de datos</a></li>
      <li><a href="444_room.html" class="no-ch">4.4.4. Room</a></li>
   </ul>
   </li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="442_ficheros.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="444_room.html" class="next"><span>Siguiente<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">4.4.3. Bases de datos</h1></header>
<article class="iDevice_wrapper UDLcontentIdevice" id="id15">
<div class="iDevice emphasis0" >
<div id="ta15_862_2" class="block iDevice_content">
<div class="exe-udlContent exe-udlContent-engagement"><section class="exe-udlContent-block"><div class="exe-udlContent-content"><div class="exe-udlContent-content-main"><p>Una base de datos o BBDD es un software que permite almacenar y recuperar datos mediante consultas inteligentes, manteniendo la coherencia entre las estructuras de datos. Existen principalmente dos tipos de BBDD: relacionales y no relacionales.</p>
<p>Para la mayoría de los casos de uso, una BBDD relacional será idónea. Por ello, los sistemas operativos móviles tienen integrado software de gestión de bases de datos para que las aplicaciones puedan utilizarlas.</p>
<p>Cuando creamos una base de datos desde nuestra aplicación, básicamente estamos creando un <strong>archivo</strong> que el sistema guardará en la carpeta privada de la app, de la misma forma que con los archivos del almacenamiento interno. De este modo se mantiene la privacidad de los datos, pues el directorio de la aplicación <strong>no es accesible</strong> para otros usuarios o aplicaciones.</p>
<p>Desde las primeras versiones de iOS y Android, la mejor forma de mantener una base de datos local ha sido mediante <strong>SQLite</strong>. Aunque existen muchos otros, el sistema de gestión de base de datos SQLite está escrito en C, por lo que es muy <strong>eficiente</strong>, es <strong>simple</strong> pero <strong>completo</strong> y ocupa muy poco.</p>
<p>Hoy en día sigue siendo el preferido y está preinstalado en el sistema. Sin embargo, debemos tener algunas consideraciones antes de usar <strong>SQLite</strong> de forma directa, porque los sistemas relacionales como este tienen algunos inconvenientes. Su lenguaje de consulta, llamado SQL (Structured Query Language), es potente, pero nada tiene que ver con los lenguajes de programación orientados a objetos actuales, de modo que existe un desacople entre el código de la aplicación y el que entiende la base de datos.</p>
<p>Para solucionar ese problema, podemos usar una librería <strong>ORM</strong> (Object Relational Mapping) que traducirá de un lenguaje al otro dentro de la aplicación sin esfuerzo por nuestra parte. Existen muchas librerías que nos ayudan a usar SQLite, pero actualmente la preferida es <strong>Room</strong>.</p></div></div></section></div>
</div>
</div>
</article>
<article class="iDevice_wrapper UDLcontentIdevice" id="id16">
<div class="iDevice emphasis0" >
<div id="ta16_863_2" class="block iDevice_content">
<div class="exe-udlContent exe-udlContent-engagement"><section class="exe-udlContent-block"><div class="exe-udlContent-content"><div class="exe-udlContent-content-main"><p>SQL es sencillo y potente, solo requiere algo de estudio y práctica. Sin embargo, como programadores, no seremos nosotros los que hablemos con la BBDD, será nuestra aplicación.</p>
<p>Veamos entonces cómo podríamos crear y usar una base de datos <strong>SQLite</strong> desde nuestra aplicación Android con las funciones integradas de bajo nivel, es decir, sin utilizar ningún <strong>ORM</strong> como <strong>Room</strong> que nos facilite las cosas.</p>
<div class="exe-fx exe-paginated">
<h2>Las tablas</h2>
<p>Imaginemos que nuestra aplicación es un videojuego y necesitamos guardar los datos de los usuarios y los puntos de cada partida. Con el DDL de SQL crearíamos dos tablas:</p>
<div class="highlighted-code language-sql">
<div>
<pre><code>CREATE TABLE jugadores (
    jugador_id INTEGER PRIMARY KEY,
    nombre TEXT NOT NULL UNIQUE,
    avatar TEXT,
    cinturon INTEGER,
);
CREATE TABLE partidas (
    partida_id INTEGER PRIMARY KEY,
    jugador_id INTEGER,
    fecha INTEGER,
    puntos INTEGER,
    nivel INTEGER
);</code></pre>
</div>
</div>
<p>La tabla <strong>jugadores</strong> almacenará a los jugadores que han echado una partida hasta ahora. Sus campos serán:</p>
<ul>
<li><strong>jugador_id</strong>, un identificador único para identificar al jugador;</li>
<li><strong>nombre</strong>, que será el alias del jugador en la interfaz gráfica del juego;</li>
<li><strong>avatar</strong>, que será una URL o ruta del sistema de archivos hacia una imagen que identifique gráficamente al jugador en el juego;</li>
<li><strong>cinturon</strong>, que no es más que el nivel que ha alcanzado el jugador en el juego por puntos o niveles superados.</li>
</ul>
<p>Por otro lado, la tabla <strong>partidas</strong> guardará los datos de todas las partidas jugadas por los diferentes jugadores, y sus campos serán:</p>
<ul>
<li><strong>partida_id</strong>, que es el identificador único de cada partida;</li>
<li><strong>jugador_id</strong>, que identifica qué jugador en la partida;</li>
<li><strong>fecha</strong> de la partida;</li>
<li><strong>puntos</strong> conseguidos por el jugador en la partida;</li>
<li><strong>nivel</strong> máximo alcanzado en la partida.</li>
</ul>
<h2>Las consultas</h2>
<p>Imaginemos que un nuevo jugador echa una partida: mediante el DML de SQL guardaríamos esa nueva información:</p>
<div class="highlighted-code language-sql">
<div>
<pre><code>INSERT INTO jugadores (jugador_id, nombre, avatar, cinturon) VALUES (69, “Ninja Rookie”, “http://img.com/ninja”, 0)
INSERT INTO partidas (partida_id, jugador_id, fecha, puntos, nivel) VALUES (3, 69, strftime('%s','now'), 30, 2)</code></pre>
</div>
</div>
<p>Con el comando <strong>INSERT INTO</strong> introducimos los datos del jugador <strong>Ninja Rookie</strong> con el código <strong>identificador 69</strong> en la tabla <strong>jugadores</strong>, y la partida que ha jugado con el <strong>identificador 3</strong> y los <strong>30</strong> <strong>puntos</strong> obtenidos hasta el <strong>nivel 2</strong> del juego se guardan en partidas.</p>
<p>Como SQLite no tiene un tipo de datos para fechas, usaremos un número entero, como el número de segundos desde 1970, una forma clásica de contar el tiempo en computación (<a href="https://es.wikipedia.org/wiki/Tiempo_Unix" target="_blank" rel="noopener"><strong>timestamp</strong></a>). De ahí la función <strong>strftime</strong>, que convierte la fecha <strong>now</strong> a segundos <strong>%s</strong> y lo pasa a entero. Cuando después quisiéramos recuperar los datos del jugador 69, haríamos la consulta:</p>
<div class="highlighted-code language-sql">
<div>
<pre><code>SELECT * FROM jugadores WHERE jugador_id = 69</code></pre>
</div>
</div>
<p>Y si quisiéramos recuperar todas las partidas del jugador 69 haríamos:</p>
<div class="highlighted-code language-sql">
<div>
<pre><code>SELECT * FROM partidas WHERE jugador_id = 69</code></pre>
</div>
</div>
<h2>Estructuramos en Android</h2>
<p>Lo primero es definir las estructuras que almacenarán nuestros datos, las tablas. Para ello heredamos de la clase <strong>SQLiteOpenHelper</strong>, que será la responsable de mantener esas<br>estructuras en el archivo de base de datos:</p>
<div class="highlighted-code language-sql">
<div>
<pre><code>class JuegoDbHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {
    ....
}</code></pre>
</div>
</div>
<p>Como vemos, necesita un contexto, el nombre del archivo donde se almacenará la BBDD y la versión actual, que como en nuestro caso será la primera, podríamos definir como 1.</p>
<p>Después sobrescribimos la función <strong>onCreate</strong> para definir las tablas que darán forma a nuestra base de datos:</p>
<div class="highlighted-code language-sql">
<div>
<pre><code>override fun onCreate(db: SQLiteDatabase) {
    db.execSQL(SQL_CREATE_JUGADORES)
    db.execSQL(SQL_CREATE_PARTIDAS)
}</code></pre>
</div>
</div>
<p>Se nos pasa un objeto <strong>db</strong> de base de datos y llamamos a su <strong>execSQL</strong>, una función que ejecutará el código SQL que se le pase.</p>
<p>Las constantes string <strong>SQL_CREATE_JUGADORES </strong>y <strong>SQL_CREATE_PARTIDAS</strong> que más tarde mostraremos son el código SQL para crear las tablas que deseamos. Si mientras creamos la BBDD desde nuestra aplicación resulta que ya existía otra con una versión anterior, se llamará a <strong>onUpdate</strong>, que será la encargada de actualizar los datos antiguos a la nueva estructura:</p>
<div class="highlighted-code language-sql">
<div>
<pre><code>override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
    db.execSQL(SQL_DELETE_JUGADORES)
    db.execSQL(SQL_DELETE_PARTIDAS)
    onCreate(db)
}</code></pre>
</div>
</div>
<p>Para no complicar el código, y puesto que solo tenemos una versión de nuestras tablas, hacemos lo más sencillo, que es eliminar las tablas antiguas y volverlas a crear con la nueva estructura, sin tener en cuenta que perderemos los datos de la versión previa en caso de que los hubiera. El código completo sería:</p>
<div class="highlighted-code language-sql">
<div>
<pre><code>import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
class JuegoDbHelper(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {
    // Se llama cuando la base de datos aun no existe y debe crearse
    override fun onCreate(db: SQLiteDatabase) {
        // Ejecutamos el SQL que crea las tablas
        db.execSQL(SQL_CREATE_JUGADORES)
        db.execSQL(SQL_CREATE_PARTIDAS)
    }
    // Se llama cuando hemos modificado la estructura de las tablas
    // y hemos incrementado el número de la versión pero aún tenemos
    // una BBDD antigua con una versión anterior, aquí se actualizará
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        // Ejecutamos el SQL que borra las tablas,
        // después el que las crea con la nueva versión
        db.execSQL(SQL_DELETE_JUGADORES)
        db.execSQL(SQL_DELETE_PARTIDAS)
        onCreate(db)
    }
    companion object {
        // Si necesitamos cambiar las tablas una vez que la
        // app está en producción, debemos incrementar este numero
        const val DATABASE_VERSION = 1
        const val DATABASE_NAME = "juego.db"
        const val TABLE_JUGADORES = "jugadores"
        private const val SQL_CREATE_JUGADORES = 
            "CREATE TABLE $TABLE_JUGADORES (" + 
            "jugador_id INTEGER PRIMARY KEY," + 
            "nombre TEXT NOT NULL UNIQUE," + 
            "avatar TEXT," + 
            "cinturon INTEGER"
        private const val SQL_DELETE_JUGADORES = "DROP TABLE IF EXISTS $TABLE_JUGADORES"
        const val TABLE_PARTIDAS = "partidas"
        private const val SQL_CREATE_PARTIDAS = 
            "CREATE TABLE $TABLE_PARTIDAS (" + 
            "partida_id INTEGER PRIMARY KEY," + 
            "jugador_id INTEGER NOT NULL," + 
            "fecha INTEGER NOT NULL," + 
            "puntos INTEGER NOT NULL," + 
            "nivel INTEGER NOT NULL"
        private const val SQL_DELETE_PARTIDAS = "DROP TABLE IF EXISTS $TABLE_PARTIDAS"
    }
}</code></pre>
</div>
</div>
<h2>Introducir datos</h2>
<p>Hemos definido los comandos SQL como constantes string para tenerlos bien definidos solo en un lugar y no desperdigados por el código. Ahora podríamos introducir datos en nuestra nueva base de datos. Como programamos con Kotlin, nuestros datos serán objetos de alguna clase. Definamos nuestra clase Jugador, asociada a la tabla jugadores:</p>
<div class="highlighted-code language-java">
<div>
<pre><code>data class jugador(
    val id: Int,
    val nombre: String,
    val avatar: String?,
    val cinturon: Int?)</code></pre>
</div>
</div>
<p>Nada más que un data class de Kotlin con los campos de nuestro jugador. Añadamos una función a la clase para insertar el propio objeto en la BBDD:</p>
<div class="highlighted-code language-java">
<div>
<pre><code>fun introducirEnBBDD(db: SQLiteDatabase) {
    // Juntamos todos los campos en una colección ContentValues
    val values = ContentValues().apply {
        put("nombre", jugador.nombre)
        put("avatar", jugador.avatar)
        put("cinturon", jugador.cinturon)
    }
    // Insertamos la fila de datos, y el sistema devuelve el id
    id = db?.insert(JuegoDbHelper.TABLE_JUGADORES, null, values)
}</code></pre>
</div>
</div>
<p>Esta nueva función <strong>introducirEnBBDD</strong> recibe por parámetro un objeto <strong>SQLiteDatabase</strong> que crearemos mediante nuestro <strong>JuegoDbHelper</strong>. Este objeto de base de datos nos permite insertar, seleccionar, actualizar y borrar. Introducimos los datos en un objeto <strong>ContentValues</strong>, que no es más que un objeto contenedor de pares clave-valor, y lamamos a la función <strong>insert</strong>, que devolverá el identificador de la fila insertada en la tabla. Para introducir un <strong>nuevo jugador</strong>, el código sería:</p>
<div class="highlighted-code language-java">
<div>
<pre><code>val dbHelper = JuegoDbHelper(context)
val db = dbHelper.writableDatabase //Creamos base de datos en modo escritura
val jugador = Jugador(69, "Ninja Rookie", "http://img.com/ninja.png", 0)
jugador.insertarEnBBDD(db)</code></pre>
</div>
</div>
<p>Primero creamos nuestra clase de ayuda para BBDD. Con ese objeto creamos nuestra base de datos db. Luego creamos el <strong>Jugador</strong>, y llamamos a su método insertarEnBBDD con el objeto <strong>db</strong>.</p>
<h2>Conclusión</h2>
<p>Utilizar las funciones de bajo nivel para manejar nuestra base de datos es posible, pero tiene ciertos inconvenientes e incomodidades:</p>
<ul>
<li>requiere mucho código para cada tabla.</li>
<li>Pasar un objeto de Kotlin a una fila de base de datos SQL es incómodo y repetitivo, entre otras cosas porque para cada acción de BBDD necesitamos desgranar los campos del objeto en pares clave-valor.</li>
<li>Necesitamos conocer el lenguaje SQL para definir las tablas y sus relaciones, y para codificar las consultas de selección, actualización y borrado.</li>
</ul>
<h2>Room</h2>
<p>Room, una librería con la que crear y acceder a los datos de nuestra BBDD SQLite de forma fácil, eficiente y orientada a objetos. Veamos cómo utilizar este ORM.</p>
</div></div></div></section></div>
</div>
</div>
</article>
<div id="packageLicense" class="cc cc-by-nc-sa">
<p><span>Obra publicada con</span> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Licencia Creative Commons Reconocimiento No comercial Compartir igual 4.0</a></p>
</div>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="442_ficheros.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="444_room.html" class="next"><span>Siguiente<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_cedec_js.js"></script></body></html>