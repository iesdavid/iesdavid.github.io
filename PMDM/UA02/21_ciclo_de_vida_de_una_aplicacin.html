<!doctype html>
<html lang="es">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="exe_highlighter.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>2.1. Ciclo de vida de una aplicación | UA02. Funcionamiento de aplicaciones </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="author" content="David Bermúdez" />
<link rel="license" type="text/html" href="http://creativecommons.org/licenses/by-sa/4.0/" />
<meta name="generator" content="eXeLearning 2.7 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="exe_highlighter.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<link rel="stylesheet" type="text/css" href="udl-content.css" />
<script type="text/javascript" src="udl-content.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
	</head>
<body class="exe-web-site" id="exe-node-1"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Saltar la navegación</a></p>
<header id="header" ><div id="headerContent">UA02. Funcionamiento de aplicaciones</div></header>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">UA2. Funcionamiento de aplicaciones</a></li>
   <li id="active"><a href="21_ciclo_de_vida_de_una_aplicacin.html" class="active daddy">2.1. Ciclo de vida de una aplicación</a>
   <ul>
      <li><a href="211_descubrimiento_instalacin_ejecucin_actualizacin_y_borrado.html" class="no-ch">2.1.1. Descubrimiento, instalación, ejecución, actualización y borrado</a></li>
      <li><a href="212_componentes_de_una_app.html" class="no-ch">2.1.2. Componentes de una App</a></li>
      <li><a href="213_android_manifest.html" class="no-ch">2.1.3. Android Manifest</a></li>
      <li><a href="214_recursos.html" class="no-ch">2.1.4. Recursos</a></li>
      <li><a href="215_la_clase_r.html" class="no-ch">2.1.5. La clase R</a></li>
   </ul>
   </li>
   <li><a href="22_modificacin_de_aplicaciones_existentes.html" class="no-ch">2.2. Modificación de aplicaciones existentes</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="index.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="211_descubrimiento_instalacin_ejecucin_actualizacin_y_borrado.html" class="next"><span>Siguiente<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">2.1. Ciclo de vida de una aplicación</h1></header>
<article class="iDevice_wrapper UDLcontentIdevice" id="id1">
<div class="iDevice emphasis0" >
<div id="ta1_836_2" class="block iDevice_content">
<div class="exe-udlContent exe-udlContent-engagement"><section class="exe-udlContent-block"><div class="exe-udlContent-content"><div class="exe-udlContent-content-main"><p>Para el desarrollo nativo de aplicaciones en Android no basta con ser un buen conocedor del código (básicamente Java) y tener buena pericia en fundamentos de programación. La peculiaridad de los dispositivos móviles, la variabilidad que entre estos existen (como ya se estudió en el capítulo anterior) y, sobre todo, la multiplicidad de recursos que son capaces de aportar estos dispositivos, hacen necesario que antes de iniciar las tareas de codificación se conozcan los fundamentos y la estructura de componentes en los que se basa una aplicación en Android.</p>
<p>Además, el correcto manejo de algunos de estos componentes (Android Manifest, clase R, permisos...) es importante si se desea que las aplicaciones desarrolladas tengan alguna proyección de mayor alcance que el límite que pueda imponer el propio equipo informático y las herramientas de desarrollo.</p></div></div></section></div>
</div>
</div>
</article>
<article class="iDevice_wrapper UDLcontentIdevice em_iDevice em_iDevice_think" id="id2">
<div class="iDevice emphasis1" >
<header class="iDevice_header" style="background-image:url(icon_think.png)"><h1 class="iDeviceTitle">Fundamentos</h1></header>
<div class="iDevice_inner">
<div class="iDevice_content_wrapper">
<div id="ta2_837_2" class="block iDevice_content">
<div class="exe-udlContent exe-udlContent-engagement"><section class="exe-udlContent-block"><div class="exe-udlContent-content"><div class="exe-udlContent-content-main"><p><img src="APP_APK.png" alt="Elaboración de una APP" style="margin-right: 10px; margin-left: 10px; float: right;" width="320" height="360">Android es un sistema operativo multiusuario basado en Linux, donde cada aplicación es considerada propiedad de un usuario distinto. El sistema asigna un identificador de usuario diferente a cada aplicación, por lo que los archivos incluidos en cada una tendrán permisos solo para ese usuario y solo él podrá tener acceso a ellos.</p>
<p>Esto hace que cada aplicación tenga su propio sistema de seguridad, con usuarios diferentes para cada una de ellas, permisos propios para cada usuario con máquinas virtuales propias y un proceso de Linux propio. De tal manera que Android utiliza el principio de menor privilegio, dando los permisos justos a cada aplicación. Todo ello lo convierte en un sistema operativo seguro.</p>
<p>No obstante, una aplicación puede solicitar permisos para acceder a datos (agenda), recursos (SD, Bluetooth) o funcionalidades (SMS, cámara) del dispositivo. Estos permisos asociados a la aplicación se conceden en la instalación de la misma o en el momento de usarlos (para versiones más modernas de Android), y los otorga el usuario.</p>
<p>Las aplicaciones Android están escritas en Java, un lenguaje de programación orientado a objetos, apoyado en determinados aspectos por XML. El SDK (kit de desarrollo de software) de Android compila el código, datos y recursos, incluyéndolo todo en un fichero APK.</p></div></div></section></div>
</div>
</div>
</div>
</div>
</article>
<article class="iDevice_wrapper UDLcontentIdevice" id="id3">
<div class="iDevice emphasis0" >
<div id="ta3_838_2" class="block iDevice_content">
<div class="exe-udlContent exe-udlContent-engagement"><section class="exe-udlContent-block"><div class="exe-udlContent-content"><div class="exe-udlContent-content-main"><p>A diferencia de otros sistemas operativos, en Android cada aplicación es un proceso separado, el usuario no decide cuándo se finaliza una aplicación, esta decisión reside en la gestión de la pila de aplicaciones del propio sistema Android, en función de las necesidades de memoria en cada momento.</p>
<p>Del mismo modo, cuando el usuario vuelve a solicitar la aplicación, el sistema se encarga de crear el proceso para mostrar la aplicación en pantalla.</p>
<p>Dependiendo del estado en el cual se encuentre el proceso, el sistema asigna una prioridad que determina la probabilidad de que la aplicación sea cerrada. Podemos verlo en la siguiente tabla:</p>
<table class="exe-table">
<tbody>
<tr>
<th>Prioridad</th>
<th>Estado de proceso</th>
<th>Estado de la actividad</th>
</tr>
<tr>
<td>Bajo o nula</td>
<td>Primer Plano, tiene el<br>foco</td>
<td>Created<br>Started<br>Resumed</td>
</tr>
<tr>
<td>Media</td>
<td>Segundo plano, perdió el<br>foco</td>
<td>Paused</td>
</tr>
<tr>
<td>Alta</td>
<td>Segundo plano, no visible</td>
<td>Stoped<br>Destroyed</td>
</tr>
</tbody>
</table></div></div></section></div>
</div>
</div>
</article>
<article class="iDevice_wrapper UDLcontentIdevice" id="id4">
<div class="iDevice emphasis0" >
<div id="ta4_839_2" class="block iDevice_content">
<div class="exe-udlContent exe-udlContent-engagement"><section class="exe-udlContent-block"><div class="exe-udlContent-content"><div class="exe-udlContent-content-main"><p>Vemos que el sistema no cerrará nunca la aplicación que tengan el foco, es decir, aquella aplicación que se está mostrando en la pantalla. Si la aplicación pierde el foco debido a que el usuario cambia de aplicación o está leyendo un mensaje o atendiendo una llamada, pasa a segundo plano y puede ser cerrada por el sistema si este necesita los recursos.</p>
<p>Es vital entender el funcionamiento del ciclo de vida de las aplicaciones para desarrollar aplicaciones robustas, ya que tenemos que manejar el ciclo de vida para determinar en qué momento recuperamos los datos de la aplicación.</p>
<p>En la tabla hemos incluido el estado de la actividad, puesto que el proceso de la aplicación está fuertemente vinculado al estado de la actividad, de modo que, para manejar el ciclo de vida desde nuestra aplicación, tenemos disponibles un conjunto de hasta seis métodos que el sistema invoca y podemos gestionar desde la actividad de la aplicación.</p></div></div></section><section class="exe-udlContent-block"><div class="exe-udlContent-content"><div class="exe-udlContent-content-main"><p>En el siguiente esquema podemos ver el ciclo vida representado de forma gráfica y el momento en el que se ejecuta cada método.</p>
<p><img src="android-lifecycle.jpg" alt="Ciclo vida Android" style="display: block; margin-left: auto; margin-right: auto;" width="560" height="637"></p></div></div></section><section class="exe-udlContent-block"><div class="exe-udlContent-content"><div class="exe-udlContent-content-main"><p>Los eventos del ciclo de vida</p>
<ul>
<li><strong>onCreate</strong>(Bundle)Representa el momento en el que la actividad se crea. Este método normalmente lo generará el asistente al crear una nueva actividad en Android, y es donde crearemos todo lo que vaya a necesitar la actividad. Si antes hemos salvado los datos de la actividad en un objeto Bundle, podremos utilizarlo para regenerarla. Normalmente no lo usaremos.</li>
<li><strong>onStart</strong>()La actividad va a pasar a estar en pantalla, aunque no necesariamente visible. Si venimos de una parada, pasaremos antes por onRestart().</li>
<li><strong>onRestart</strong>()Anterior a onStart() cuando procedemos de una llamada a onStop().</li>
<li><strong>onResume</strong>()La actividad va a empezar a responder a la interacción del usuario.</li>
<li><strong>onPause</strong>()La actividad va a dejar de responder a la interacción del usuario.</li>
<li><strong>onStop</strong>()La actividad ha pasado completamente a segundo plano.</li>
<li><strong>onDestroy</strong>()La actividad va a ser destruida y sus recursos liberados.</li>
</ul></div></div></section><section class="exe-udlContent-block"><div class="exe-udlContent-content"><div class="exe-udlContent-content-main"><p>Cuando necesitemos implementar uno de estos métodos, lo haremos añadiendo a nuestra actividad con estos perfiles:</p>
<div class="highlighted-code language-java line-numbers">
<div>
<pre><code>public class MiActividad extends Activity {
     protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
...
}
     protected void onStart() {
super.onStart();
...
}  
     protected void onRestart() {
super.onRestart();
...
}
     protected void onResume() {
super.onResume();
...
}
     protected void onPause() {
...
super.onPause();
}
     protected void onStop() {
...
onStop();
}
     protected void onDestroy() {
...
super.onDestroy();
}
}</code></pre>
</div>
</div>
<p>Es importante mantener la llamada al método de la superclase para no encontrarnos con sorpresas. Las tareas de cada evento que están por encima de nuestra actividad deben mantenerse. Esta llamada irá al principio de los eventos de entrada, y al final de los de salida. De esa forma nos evitaremos sorpresas, ya que los elementos de la actividad que necesitemos pero que no estarán bajo nuestro control estarán creados antes de usarlos, y se destruirán después.<br><br></p></div></div></section></div>
</div>
</div>
</article>
<article class="iDevice_wrapper UDLcontentIdevice em_iDevice em_iDevice_technology" id="id5">
<div class="iDevice emphasis1" >
<header class="iDevice_header" style="background-image:url(icon_technology.png)"><h1 class="iDeviceTitle">Ejercicio práctico</h1></header>
<div class="iDevice_inner">
<div class="iDevice_content_wrapper">
<div id="ta5_840_2" class="block iDevice_content">
<div class="exe-udlContent exe-udlContent-engagement"><section class="exe-udlContent-block"><div class="exe-udlContent-content"><div class="exe-udlContent-content-main"><p>Para comprender mejor el ciclo de vida, vamos a ponerlo en práctica en el proyecto que hemos creado previamente. Vamos al archivo <strong>MainActivity.kt</strong>; si no puedes localizarlo, repasa el punto 5 de la Unidad anterior, en el que habla sobre la estructura del IDE.</p>
<p>Una vez localizado, sobrescribe los métodos <strong>onCreate()</strong>, <strong>onRestart()</strong>, <strong>onStart()</strong>, <strong>onResume()</strong>, <strong>onPause()</strong>, <strong>onStop()</strong> y <strong>onDestroy().</strong></p>
<p>En cada uno de los métodos utiliza la función <strong>Log.d()</strong> con un texto descriptivo del método.</p>
<p>La clase <strong>android.util.Log</strong> dispone de diferentes funciones para escribir en un log, es decir, un archivo en el que aparecen mensajes relevantes sobre la ejecución de la aplicación.</p>
<p><strong>Log.d()</strong> sirve para mensajes de depuración, que tienen menos prioridad que los mensajes <strong>Log.e()</strong>, que son errores y se muestran en rojo en las salida de mensajes Logcat. Entonces, veamos un ejemplo cómo sobrescribimos la función <strong>onCreate()</strong> para mostrar un mensaje:</p>
<div class="highlighted-code language-java line-numbers">
<div>
<pre><code>override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    Log.d(TAG, "Ciclo de vida - onCreate")
}</code></pre>
</div>
</div>
<p>Observamos cómo utilizamos <strong>override</strong> para informar al compilador de que no estamos creando un método nuevo, sino sobrescribiendo el de la clase padre, que tiene igual nombre y parámetros.</p>
<p>Al sobrescribir funciones de las clases del sistema Android, recuerda que en la mayoría de los casos será conveniente llamar primero al método original. Lo haremos al principio del método, mediante el objeto <strong>super</strong>, que es la palabra clave para identificar al objeto padre.</p>
<p>Luego hemos añadido la llamada <strong>Log</strong>. La constante <strong>TAG</strong> sirve ver en el log desde qué clase imprimimos el mensaje. Podríamos definirla de la siguiente manera:</p>
<div class="highlighted-code language-java line-numbers">
<div>
<pre><code>companion object {
    private const val TAG = "MainActivity"
}</code></pre>
</div>
</div>
<p>Ejecuta la aplicación en el emulador y comprueba qué resultados obtienes en el Logcat.</p>
<p>Luego cambia a otra aplicación y comprueba qué métodos del ciclo de vida se han ejecutado. Cierra la aplicación. ¿Qué métodos se ejecutan?</p></div></div></section></div>
</div>
</div>
</div>
</div>
</article>
<div id="packageLicense" class="cc cc-by-sa">
<p><span>Obra publicada con</span> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Licencia Creative Commons Reconocimiento Compartir igual 4.0</a></p>
</div>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="index.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="211_descubrimiento_instalacin_ejecucin_actualizacin_y_borrado.html" class="next"><span>Siguiente<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_cedec_js.js"></script></body></html>